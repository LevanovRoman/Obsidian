### Какие знаете шаблоны проектирования? Расскажите о двух шаблонах, используемых в работе.

Существует множество шаблонов проектирования, которые используются в различных областях программирования. Расскажу о двух наиболее распространенных шаблонах:

`Фабричный метод (Factory method)` - это шаблон проектирования, который предоставляет интерфейс для создания объектов некоторого класса, но позволяет подклассам выбирать классы, которые должны быть созданы. То есть данный шаблон делегирует ответственность за создание объектов своим подклассам.  
Пример использования фабричного метода может быть следующим: у вас есть базовый класс "Фигура", от которого наследуются классы "Круг", "Прямоугольник" и т.д. Каждый из этих классов должен уметь создавать объекты своего типа. В этом случае можно воспользоваться фабричным методом, чтобы вынести логику создания объектов в отдельный класс.

`Одиночка (Singleton)` - это шаблон проектирования, который гарантирует, что у класса есть только один экземпляр, а также предоставляет глобальную точку доступа к этому экземпляру.  
Пример использования шаблона Одиночка может быть следующим: у вас есть класс, который предоставляет доступ к базе данных. В этом случае можно сделать этот класс Одиночкой, чтобы гарантировать, что у нас будет только один экземпляр класса, который будет работать с базой данных, и избежать проблем с несогласованными изменениями данных в разных экземплярах класса.


### Какие паттерны GoF вы использовали на практике? Приведите примеры.

- `Паттерн "Фабричный метод" (Factory Method)` - использовался для создания объектов определенного типа, в зависимости от параметров. Например, если требуется создать экземпляр класса, который может иметь различные реализации, то фабричный метод обеспечивает гибкость и удобство при создании объектов.
    
- `Паттерн "Абстрактная фабрика" (Abstract Factory)` - использовался для создания семейств связанных объектов. Например, если требуется создать объекты, которые зависят друг от друга и должны быть созданы вместе, то абстрактная фабрика предоставляет механизм для этого.
    
- `Паттерн "Одиночка" (Singleton)` - использовался для создания объекта, который может быть создан только один раз. Например, если требуется создать объект, который используется множество раз в приложении, то с помощью паттерна Одиночка можно гарантировать, что он будет создан только один раз.
    
- `Паттерн "Стратегия" (Strategy)` - использовался для определения алгоритма, который может быть заменен на другой алгоритм без изменения интерфейса. Например, если требуется реализовать алгоритм сортировки, то можно использовать паттерн Стратегия для того, чтобы выбирать различные методы сортировки в зависимости от конкретных требований.
    
- `Паттерн "Наблюдатель" (Observer)` - использовался для создания механизма, который позволяет объектам-наблюдателям получать оповещения об изменении состояния других объектов. Например, если требуется создать систему, которая обрабатывает события, то паттерн Наблюдатель может быть использован для того, чтобы отправлять уведомления о событиях всем заинтересованным объектам.
    
- `Паттерн "Декоратор" (Decorator)` - использовался для динамического добавления функциональности к объекту без изменения его класса. Например, если требуется добавить дополнительное поведение к объекту, то можно использовать паттерн Декоратор, который позволяет обернуть объект в другой объект с дополнительным поведением.
    
- `Паттерн "Адаптер" (Adapter)` - использовался для преобразования интерфейса одного класса в интерфейс другого класса. Например, если имеется класс с неподходящим интерфейсом для использования в приложении, то можно создать адаптер, который преобразует интерфейс класса в нужный интерфейс.
    
- `Паттерн "Итератор" (Iterator)` - использовался для последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления. Например, если требуется перебрать элементы коллекции в порядке их добавления, то можно использовать паттерн Итератор, который предоставляет методы для доступа к элементам коллекции.
    
- `Паттерн "Шаблонный метод" (Template Method)` - использовался для определения основных шагов алгоритма, оставляя подклассам возможность переопределения некоторых шагов. Например, если требуется реализовать алгоритм, который имеет схожие шаги, но различную реализацию для каждого шага, то можно использовать паттерн Шаблонный метод, чтобы предоставить базовую реализацию алгоритма и дать возможность подклассам переопределять отдельные шаги.
    
- `Паттерн "Фасад" (Facade)` - использовался для предоставления упрощенного интерфейса для сложной системы. Например, если имеется сложная система, которая состоит из многих классов и компонентов, то можно создать фасад, который скрывает сложность системы и предоставляет простой интерфейс для взаимодействия с ней.
    
- `Паттерн "Компоновщик" (Composite)` - использовался для создания иерархических древовидных структур объектов, которые могут быть обработаны единообразно. Например, если требуется представить структуру файловой системы, то можно использовать паттерн Компоновщик для создания древовидной структуры, где папки и файлы являются узлами дерева.
    
- `Паттерн "Прототип" (Prototype)` - использовался для создания новых объектов путем клонирования существующих объектов. Например, если требуется создать множество объектов с одинаковыми свойствами, то можно использовать паттерн Прототип, чтобы создать первоначальный объект и затем клонировать его для создания остальных объектов.
    
- `Паттерн "Цепочка обязанностей" (Chain of Responsibility)` - использовался для построения цепочки объектов, которые могут обрабатывать запросы последовательно до тех пор, пока один из объектов не обработает запрос. Например, если имеется система обработки запросов и каждый запрос может быть обработан несколькими объектами, то можно использовать паттерн Цепочка обязанностей, чтобы создать цепочку объектов, которые будут обрабатывать запросы последовательно.
    
- `Паттерн "Состояние" (State)` - использовался для изменения поведения объекта в зависимости от его состояния. Например, если имеется объект, который может находиться в различных состояниях, то можно использовать паттерн Состояние, чтобы определить различное поведение объекта в зависимости от его текущего состояния.
    
- `Паттерн "Посетитель" (Visitor)` - использовался для добавления новых операций к классам, не изменяя их исходного кода. Например, если имеется множество классов и требуется добавить новую операцию, которая будет выполняться для каждого класса, то можно использовать паттерн Посетитель, чтобы добавить эту операцию без изменения исходного кода классов.
    
- `Паттерн "Мост" (Bridge)` - использовался для разделения абстракции и реализации, чтобы они могли изменяться независимо друг от друга. Например, если имеется класс, который представляет графический объект, то можно использовать паттерн Мост, чтобы разделить абстракцию графического объекта и его реализацию.
    
- `Паттерн "Легковес" (Flyweight)` - использовался для оптимизации работы с большим количеством мелких объектов, которые могут быть разделены на общие и уникальные части. Например, если требуется работать с большим количеством объектов, каждый из которых имеет много общих идентификаторов, то можно использовать паттерн Легковес, чтобы разделить общие и уникальные части объектов и оптимизировать использование памяти.
    
- `Паттерн "Прокси" (Proxy)` - использовался для создания объекта-заместителя, который может контролировать доступ к другому объекту. Например, если имеется объект, к которому нужно предоставить доступ только определенным пользователям, то можно использовать паттерн Прокси, который будет контролировать доступ к этому объекту.
    
- `Паттерн "Команда" (Command)` - использовался для инкапсуляции запроса в виде объекта, что позволяет отделить источник запроса от его исполнения. Например, если требуется реализовать систему, которая обрабатывает запросы, то можно использовать паттерн Команда, чтобы инкапсулировать запрос в виде объекта и передавать его на обработку.
    
- `Паттерн "Интерпретатор" (Interpreter)` - использовался для определения грамматики языка и создания интерпретатора для выполнения заданных операций. Например, если имеется язык, который нужно интерпретировать, то можно использовать паттерн Интерпретатор, который предоставляет механизм для описания грамматики языка и выполнения заданных операций.
    
- `Паттерн "Снимок" (Memento)` - использовался для сохранения состояния объекта и его восстановления в будущем. Например, если требуется сохранить состояние объекта перед выполнением каких-то действий, то можно использовать паттерн Снимок, чтобы сохранить его состояние и восстановить его в будущем.
    
- `Паттерн "Строитель" (Builder)` - использовался для создания сложных объектов путем последовательного добавления их компонентов. Например, если требуется создать объекты, которые имеют много параметров и зависят друг от друга, то можно использовать паттерн Строитель, который позволяет последовательно добавлять компоненты объекта.
    
- `Паттерн "Инкапсуляция состояния" (Encapsulated State)` - использовался для инкапсуляции изменений состояния объекта в соответствующие классы. Например, если требуется реализовать систему, которая обработает изменения состояний объектов, то можно использовать паттерн Инкапсуляция состояния, который позволяет инкапсулировать изменения состояния объекта в соответствующие классы.
    
- `Паттерн "Соблюдение интерфейса" (Interface Compliance)` - использовался для создания классов, которые соответствуют определенному интерфейсу. Например, если требуется реализовать систему, которая работает с объектами, то можно использовать паттерн Соблюдение интерфейса, который обеспечивает соответствие класса заданному интерфейсу.
    
- `Паттерн "Реестр" (Registry)` - использовался для хранения ссылок на объекты в централизованном месте. Например, если требуется иметь доступ к объектам из разных частей приложения, то можно использовать паттерн Реестр, который позволяет хранить ссылки на объекты в централизованном месте и давать доступ к ним из разных частей приложения.
### Расскажите о Heap и Stack памяти в Java. В чем разница между ними? Где хранятся примитивы?

Heap и Stack - это две области памяти, используемые в Java для хранения разных типов данных.

`Heap (куча)` - это область памяти, где хранятся объекты, созданные во время выполнения программы. Объекты в куче могут быть созданы динамически во время выполнения программы, а также могут передаваться между методами в качестве параметров или возвращаться из методов в виде результата. В куче хранятся все объекты Java, включая массивы и строки.

`Stack (стэк)` - это область памяти, где хранятся переменные метода и ссылки на объекты в куче, а также информация о вызовах методов. Каждый поток имеет свой собственный стек, который используется для хранения временных данных во время выполнения метода. Когда метод выполняется, его локальные переменные и аргументы помещаются на вершину стека. Когда метод завершается, эти данные удаляются из стека.

Примитивные типы данных, такие как int, boolean, double и другие, хранятся на стеке. Это происходит потому, что примитивы не являются объектами и не нуждаются в дополнительной памяти для хранения информации о них. Вместо этого значения примитивных типов можно быстро сохранять и получать из стека.

Разница между Heap и Stack заключается в том, что на стеке хранятся данные методов, которые имеют короткий жизненный цикл, а на куче - долгоживущие объекты. Кроме того, размер стека обычно ограничен, тогда как размер кучи может быть увеличен по мере необходимости с помощью опции JVM -Xmx.
### Опишите жизненный цикл Java-объекта. Как объект переходит из одной области памяти Garbage Collector в другую? Что является триггером такого перехода?

Жизненный цикл Java-объекта начинается с его создания и заканчивается, когда на него больше нет ссылок и он становится доступным для сборки мусора.

- `Создание объекта` - объект создается оператором new или другим способом создания экземпляров.
    
- `Начальное состояние` - после создания объект находится в начальном состоянии, его поля неинициализированы.
    
- `Инициализация объекта` - поля объекта инициализируются значениями по умолчанию или заданными значениями.
    
- `Использование объекта` - объект используется в программе как требуется.
    
- `Выход из области видимости` - если ссылка на объект выходит за пределы блока, метода или класса, где был создан объект, то объект становится доступен для сборки мусора.
    
- `Сборка мусора` - когда на объект больше нет ссылок, он становится доступным для сборки мусора JVM. Сборщик мусора удаляет объект из памяти JVM, освобождая занимаемое им пространство.
    

Когда объект становится доступным для сборки мусора, он может быть перемещен из одной области памяти в другую. Это делается с помощью Garbage Collector (GC), который периодически проходит по всей памяти JVM и удаляет неиспользуемые объекты, освобождая занимаемую ими память.

GC использует различные алгоритмы для определения, какие объекты можно удалить, и когда это делать. Основной триггером для перехода объекта на сборку мусора является отсутствие ссылок на этот объект. Если объект больше не доступен никаким частям программы, то он будет помечен как "ненужный" и может быть удален из памяти JVM в следующий раз, когда запустится GC.

Объект может также быть перемещен из одной области памяти в другую, если она была выделена для другого поколения объектов. Например, если объект переживает первый цикл сборки мусора и ему присваивается более долгосрочное существование, то его можно переместить в область памяти поколения, где объекты живут подольше.
### Каков принцип работы и области памяти Garbage Collector?

`Garbage Collector (сборщик мусора)` - это компонент, отвечающий за автоматическое управление памятью в программе. Он работает по принципу обнаружения и удаления объектов, которые больше не нужны программе.

Принцип работы Garbage Collector заключается в том, что он периодически сканирует области памяти программы, определяя, какие объекты больше не используются. Объекты, на которые нет ссылок или на которые существуют только циклические ссылки, считаются мусором и удаляются из памяти.

Область памяти, управляемая Garbage Collector, называется кучей (heap). Куча делится на две части: молодую поколение и старшее поколение. Новые объекты помещаются в молодую поколение. При достижении определенного порога заполнения молодой поколения происходит сборка мусора (young GC), при которой все объекты, которые еще используются, перемещаются в старшее поколение. Старшее поколение подвергается сборке мусора реже, но при этом происходит более глубокое сканирование всей кучи.

Таким образом, Garbage Collector позволяет программисту избавиться от необходимости вручную управлять памятью. Он автоматически определяет, какие объекты больше не нужны и освобождает память для других объектов. Это упрощает разработку программ и повышает безопасность, так как снижается вероятность ошибок, связанных с утечками памяти.
### Как работает Garbage Collector? Расскажите о Reference counting и Tracing.

`Garbage Collector (сборщик мусора)` - это компонент, который автоматически управляет памятью в программе. Он работает по принципу обнаружения и удаления объектов, которые больше не нужны программе. Существует два основных подхода к реализации Garbage Collector: Reference counting и Tracing.

`Reference counting` - это метод, при котором каждый объект в программе имеет счетчик ссылок. Когда создается новый объект, его счетчик ссылок устанавливается в 1. Каждый раз, когда объект используется, его счетчик ссылок увеличивается на 1. Когда объект больше не нужен, его счетчик ссылок уменьшается на 1. Когда счетчик ссылок становится равным нулю, объект удаляется из памяти. Этот метод хорошо работает в простых программах, но может приводить к проблемам в сложных программах, так как счетчики ссылок могут быть циклическими.

`Tracing` - это метод, при котором Garbage Collector сканирует память программы и определяет, какие объекты больше не нужны программе. Для этого он использует алгоритмы маркировки и освобождения. В алгоритме маркировки Garbage Collector проходит по всем объектам в памяти и маркирует их как "живые" или "мертвые". Затем Garbage Collector освобождает память, занятую "мертвыми" объектами. Таким образом, Tracing позволяет автоматически удалять объекты, на которые больше нет ссылок, даже если они связаны циклическими ссылками.

Tracing является более эффективным методом, чем Reference counting, так как он позволяет избежать проблем с циклическими ссылками и автоматически определяет, какие объекты больше не нужны программе. Однако он также требует больших ресурсов компьютера для сканирования памяти и может приводить к задержкам в работе программы.
### Расскажите, в чем разница между WeakReference и SoftReference?

В Java существует два типа ссылок на объекты: WeakReference и SoftReference. Оба типа ссылок позволяют избежать утечек памяти в приложениях, где объекты должны быть сохранены только до тех пор, пока они нужны.

Однако между этими двумя типами ссылок есть различия в поведении при работе с Garbage Collector (сборщиком мусора) в JVM.

`WeakReference` - это тип ссылки, который указывает на объект, который может быть удален из памяти JVM, когда он больше не используется в программе, даже если у него есть активные ссылки. Таким образом, объект, на который указывает WeakReference, может быть удален GC в любой момент времени.

`SoftReference` - это тип ссылки, который указывает на объект, который будет удален из памяти JVM только в том случае, если системе необходимо освободить место в куче. Это означает, что объект, на который указывает SoftReference, будет удален только в том случае, если память в куче заканчивается и других свободных ресурсов нет.

Таким образом, SoftReference более "мягкая" ссылка, чем WeakReference, поскольку объект, на который указывает SoftReference, не будет удален из памяти JVM до тех пор, пока это не станет абсолютно необходимым.

В приложениях SoftReference используется обычно для кэширования и хранения временных данных, в то время как WeakReference - для хранения слабых ссылок на объекты, которые могут быть удалены GC в любой момент времени.

### Расскажите о принципах работы Kubernetes.

`Kubernetes (K8s)` - это открытая система управления контейнерами, которая позволяет автоматизировать развертывание, масштабирование и управление приложениями в контейнерах. Она была разработана компанией Google и сейчас поддерживается Cloud Native Computing Foundation.

Основные принципы работы Kubernetes:

- `Контейнеризация`: Kubernetes работает с Docker-контейнерами для управления их созданием, развертыванием и уничтожением.
    
- `Микросервисная архитектура`: Kubernetes поддерживает модель микросервисов, где приложение состоит из нескольких независимых сервисов, каждый из которых работает в своем контейнере.
    
- `Декларативное управление`: Kubernetes использует YAML-файлы для описания конфигурации приложения и его компонентов. Это позволяет декларативно определять желаемое состояние приложения и автоматически развертывать его на основе этой конфигурации.
    
- `Самоисцеление`: Kubernetes обеспечивает высокую доступность и отказоустойчивость приложений благодаря возможности перезапуска контейнеров при их аварийном завершении, а также переноса работающих контейнеров на другие узлы кластера в случае отказа.
    
- `Масштабирование`: Kubernetes позволяет масштабировать приложение горизонтально путем добавления или удаления реплик подсистемы (Deployment) в зависимости от нагрузки.
    
- `Сетевое взаимодействие`: Kubernetes обеспечивает возможность взаимодействия между сервисами, используя сетевые протоколы и механизмы Service Discovery.
    

Кubernetes использует концепцию узлов (Node), которые являются компьютерами или виртуальными машинами, на которых работают контейнеры. Узлы объединяются в кластер, который управляется мастер-узлом (Master Node). Мастер-узел управляет состоянием кластера, выполняет планирование задач и координирует работу узлов кластера.

Приложения в Kubernetes представлены как подсистемы (Pods), каждая из которых содержит один или несколько контейнеров. `Pod` - это самая маленькая единица развертывания в Kubernetes, и он является базовой единицей масштабирования и управления доступностью для приложений.

Для управления приложениями в Kubernetes используются объекты API, такие как Deployment, Service, ConfigMap, Secret и другие. `Deployment` - это объект, который определяет желаемое состояние приложения и управляет его развертыванием и масштабированием. `Service` - это объект, который обеспечивает доступность к подам и балансировку нагрузки между ними.

Kubernetes имеет широкий спектр возможностей для управления контейнеризованными приложениями, и его принципы работы позволяют легко масштабировать и управлять приложениями в условиях высоконагруженной среды.

### Что такое прокси-объект? Приведите примеры.

Прокси-объект (Proxy Object) - это объект, который выступает в качестве заменителя другого объекта и контролирует доступ к нему. Прокси-объект может использоваться для передачи запросов к оригинальному объекту через промежуточный уровень, что позволяет выполнять дополнительную обработку или проверку перед выполнением запроса.

В Java прокси-объекты создаются с помощью интерфейсов. Если у нас есть интерфейс, который определяет методы, которые должны вызываться на оригинальном объекте, мы можем создать прокси-объект, который реализует этот интерфейс и перенаправляет вызовы методов к оригинальному объекту. При этом мы можем выполнять нужные операции до или после вызова методов на оригинальном объекте.

Примеры использования прокси-объектов в Java:

- `Кэширование данных`: если мы хотим кэшировать результаты вызовов методов на объекте, мы можем создать прокси-объект, который будет хранить результаты предыдущих вызовов и возвращать их без вызова методов на оригинальном объекте.
    
- `Логирование`: мы можем создать прокси-объект, который будет записывать информацию о вызовах методов на оригинальном объекте в лог-файл, чтобы отслеживать его работу.
    
- `Удаленный доступ`: прокси-объекты могут использоваться для организации удаленного доступа к объектам через сеть. При этом прокси-объект на клиентской стороне будет передавать запросы на вызов методов на сервер, а прокси-объект на серверной стороне уже будет вызывать методы на реальном объекте и возвращать результат клиенту.

### Что такое High Cohesion и Low Coupling? Приведите примеры.

High Cohesion и Low Coupling - это два принципа объектно-ориентированного программирования, которые направлены на улучшение качества кода и его поддержки.

`High Cohesion (Высокая связность)` - это принцип, в соответствии с которым каждый модуль должен иметь только одну ответственность и все его элементы должны быть тесно связаны между собой. Это означает, что каждый модуль должен быть структурирован таким образом, чтобы его элементы выполняли только свои задачи, без лишних действий и зависимостей от других модулей. Это позволяет легко поддерживать код и изменять его без риска нарушения работы других модулей.

Пример High Cohesion: класс для работы с базой данных должен содержать только методы для работы с базой данных, а не методы для работы с интерфейсом пользователя.

`Low Coupling (Низкая связность)` - это принцип, в соответствии с которым модули программы должны быть слабо связаны друг с другом. Это означает, что каждый модуль должен иметь минимальные зависимости от других модулей, чтобы можно было легко менять, удалять или заменять его без изменения других модулей. Это также позволяет легче тестировать и поддерживать код.

Пример Low Coupling: класс для работы с базой данных не должен содержать зависимости от интерфейса пользователя или других модулей, чтобы можно было легко заменить его на другую реализацию базы данных.

Общий принцип High Cohesion и Low Coupling заключается в том, что каждый модуль должен иметь только одну ответственность и минимально зависеть от других модулей, чтобы код был легко читаемым, понятным и поддерживаемым. Это позволяет создавать более эффективные, надежные и масштабируемые программы.

