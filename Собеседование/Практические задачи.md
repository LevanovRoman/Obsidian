###  Valid parentheses (задача из LeetCode).

Условие задачи:  
дана строка, содержащая только символы '(', ')', '{', '}', '[' и ']', определить, является ли последовательность скобок правильной.

Последовательность скобок считается правильной, если:

- каждая открывающая скобка имеет соответствующую закрывающую скобку,
    
- последовательность скобок может быть пустой,
    
- скобки должны закрываться в правильном порядке.
    

Примеры:  
Вход: "()", Выход: true  
Вход: "()[]{}", Выход: true  
Вход: "(]", Выход: false  
Вход: "([)]", Выход: false  
Вход: "{[]}", Выход: true

Решение:

```
import java.util.Stack;

class Solution {
	public boolean isValid(String s) {        
		Stack<Character> stack = new Stack<>();        
		for(char c : s.toCharArray()) {            
			if(c=='(' || c=='{' || c=='[') { 
				// если символ - открывающая скобка, помещаем его в стек                
				stack.push(c);           
			} else if(!stack.isEmpty() && ((c==')' && stack.peek()=='(') || (c=='}' && stack.peek()=='{') || (c==']' && stack.peek()=='['))) {
			 // если символ - закрывающая скобка и она соответствует верхней скобке в стеке, удаляем верхнюю скобку из стека
			 stack.pop();           
			} else { // иначе последовательность неправильная 
			        return false;            
			        }        
			}        
			return stack.isEmpty(); // если стек пустой, то последовательность правильная   
	}
}
```

Идея алгоритма заключается в использовании стека для хранения открывающих скобок. При каждом обнаружении символа скобки мы определяем, является ли он открывающей скобкой или закрывающей. Если это открывающая скобка, мы помещаем его в стек. Если это закрывающая скобка, мы удаляем соответствующую открывающую скобку из стека. Если стек оказывается пустым в конце строки, это означает, что последовательность была правильной.
### Reverse Linked List (задача из LeetCode).

Условие задачи:  
дан связный список (linked list), поменять порядок элементов на противоположный.

Примеры:  
Вход: 1->2->3->4->5, Выход: 5->4->3->2->1  
Вход: 1, Выход: 1

Решение на Java:

```
class Solution {
	public ListNode reverseList(ListNode head) {
	    ListNode prev = null; // предыдущий узел       
	    ListNode curr = head; // текущий узел        
	    while(curr != null) { // пока не достигнем конца списка
	        ListNode nextTemp = curr.next; // сохраняем ссылку на следующий узел            
	        curr.next = prev; // меняем ссылку у текущего узла на предыдущий узел            
	        prev = curr; // перемещаем указатель на предыдущий узел на текущий узел            
	        curr = nextTemp; // перемещаем указатель на текущий узел на следующий узел        
	    }        
	    return prev; // возвращаем новую голову списка (бывший последний элемент)    
	}

}
```

Идея алгоритма заключается в итеративном переборе элементов связного списка с помощью указателей. В начале мы устанавливаем указатель на предыдущий узел равным null, а указатель на текущий узел равным голове списка. Затем мы перебираем каждый узел, меняем ссылку на следующий узел на ссылку на предыдущий узел, перемещаем указатель на предыдущий узел на текущий узел и перемещаем указатель на текущий узел на следующий узел. Когда мы доходим до конца списка, возвращаем новую голову списка (бывший последний элемент).
### Даны String s, найти длину максимального substring без повтора символов.

Для решения данной задачи можно использовать алгоритм двух указателей (sliding window). Идея заключается в создании окна, которое будет представлять собой текущий подстроку без повтора символов. Мы будем продвигать правый указатель по строке и добавлять новые символы в наше окно, пока не найдем повторяющийся символ. Когда мы обнаруживаем повторяющийся символ, мы продвигаем левый указатель до тех пор, пока удаляем все повторяющиеся символы из нашего окна.

Вот как это может быть реализовано на Java:

```
public int lengthOfLongestSubstring(String s) {
	Set<Character> set = new HashSet<>(); // множество для хранения уникальных символов    
	int left = 0; // левый указатель    
	int right = 0; // правый указатель    
	int maxLen = 0; // длина максимальной подстроки без повтора символов    
	while (right < s.length()) { // пока правый указатель не достиг конца строки        // если символ не повторяется, добавляем его в множество и расширяем окно        
		if (!set.contains(s.charAt(right))) {  
		    set.add(s.charAt(right));            
		    right++;            
		    maxLen = Math.max(maxLen, set.size()); // обновляем максимальную длину подстроки при необходимости        
		} else { // если символ уже есть в множестве, сужаем окно
		    set.remove(s.charAt(left));            
		    left++;        
		}    
	}    
	return maxLen;
}
```

Здесь мы используем множество для хранения уникальных символов в текущей подстроке. При каждом шаге мы будем проверять, содержит ли множество новый символ. Если да, то мы его добавляем и расширяем наше окно. Если нет, мы сужаем окно, удаляя символы слева до тех пор, пока не уберем дубликат.

Алгоритм работает за время O(n), где n - длина строки s.
### Определить, является ли односвязный LinkedList палиндромом.

Для определения, является ли односвязный LinkedList палиндромом, можно использовать два указателя (следующий и предыдущий) и преобразование списка в массив.

Алгоритм будет заключаться в следующих шагах:

- Преобразовать список в массив для упрощения работы с данными.
    
- Использовать два указателя - левый и правый, указывающие на начало и конец массива соответственно.
    
- Сравнивать элементы, на которые указывают левый и правый указатели. Если они не равны, то список не может быть палиндромом. Если они равны, двигаем левый указатель вправо, а правый - влево, и продолжаем сравнивать элементы до тех пор, пока указатели не пересекутся. Вот как это может быть реализовано на Java:
    

```
public boolean isPalindrome(ListNode head) {
	List<Integer> list = new ArrayList<>(); // преобразуем список в массив    
	while(head != null) { 
	    list.add(head.val);       
	    head = head.next;   
	}    
	int left = 0; // левый указатель    
	int right = list.size() - 1; // правый указатель    
	while(left < right) { // пока указатели не пересекутся
	    if(!list.get(left).equals(list.get(right))) { // если элементы не равны, список не палиндром            
		    return false;        
		}       
		left++; // двигаем левый указатель вправо        
		right--; // двигаем правый указатель влево    
	}    
	return true; // если список палиндром, возвращаем true
}
```

Здесь мы сначала преобразуем список в массив для упрощения работы с данными. Затем мы используем два указателя - левый и правый, указывающие на начало и конец массива соответственно. Мы будем перемещать левый указатель вправо и правый - влево, сравнивая элементы, на которые они указывают. Если они не равны, список не является палиндромом. Если они равны, мы продолжаем сравнивать элементы до тех пор, пока указатели не пересекутся.

Алгоритм работает за время O(n), где n - длина списка.

### Реализовать сервис, который на вход принимает url и возвращает краткую версию (вроде bit.ly/86gfr3 ).

Для реализации такого сервиса можно использовать следующий подход:

- Создать REST-контроллер, который будет принимать POST-запросы с JSON-объектом, содержащим поле "url".
    
- Внутри контроллера получить оригинальный URL из JSON-объекта.
    
- Сгенерировать случайную строку из букв и цифр, например, при помощи класса java.util.UUID.
    
- Добавить эту строку в базу данных вместе с оригинальным URL.
    
- Сформировать краткий URL, добавив сгенерированную строку к основному домену (например, [myshortener.com](http://myshortener.com/)).
    
- Отправить клиенту JSON-объект с полем "shortUrl", содержащим сформированный краткий URL.
    

Пример кода для контроллера на Spring Boot:

```
@RestControllerpublic class ShortenerController {    @Autowired    private ShortenerService shortenerService;    @PostMapping("/shorten")    public ShortenResponse shortenUrl(@RequestBody ShortenRequest request) {        String originalUrl = request.getUrl();        String shortUrl = shortenerService.shorten(originalUrl);        return new ShortenResponse(shortUrl);    }}class ShortenRequest {    private String url;        public String getUrl() {        return url;    }        public void setUrl(String url) {        this.url = url;    }}class ShortenResponse {    private String shortUrl;        public ShortenResponse(String shortUrl) {        this.shortUrl = shortUrl;    }        public String getShortUrl() {        return shortUrl;    }        public void setShortUrl(String shortUrl) {        this.shortUrl = shortUrl;    }}
```

Пример кода для сервиса, который генерирует случайную строку и сохраняет URL в базу данных:

```
@Servicepublic class ShortenerService {    @Autowired    private ShortUrlRepository shortUrlRepository;    public String shorten(String originalUrl) {        String shortId = UUID.randomUUID().toString().substring(0, 7);        String shortUrl = "https://myshortener.com/" + shortId;        ShortUrlEntity entity = new ShortUrlEntity(originalUrl, shortUrl);        shortUrlRepository.save(entity);        return shortUrl;    }}@Entity@Table(name = "short_urls")class ShortUrlEntity {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @Column(name = "original_url")    private String originalUrl;    @Column(name = "short_url")    private String shortUrl;    public ShortUrlEntity(String originalUrl, String shortUrl) {        this.originalUrl = originalUrl;        this.shortUrl = shortUrl;    }    public Long getId() {        return id;    }    public void setId(Long id) {        this.id = id;    }    public String getOriginalUrl() {        return originalUrl;    }    public void setOriginalUrl(String originalUrl) {        this.originalUrl = originalUrl;    }    public String getShortUrl() {        return shortUrl;    }    public void setShortUrl(String shortUrl) {        this.shortUrl = shortUrl;    }}interface ShortUrlRepository extends JpaRepository<ShortUrlEntity, Long> {}
```

Пример использования сервиса в тестовом клиенте на Java:

```
public class ShortenerClient {    public static void main(String[] args) {        String longUrl = "https://www.google.com/search?q=java+shortener";        String shortUrl = shorten(longUrl);        System.out.println("Short URL for " + longUrl + " is " + shortUrl);    }    private static String shorten(String url) {        RestTemplate restTemplate = new RestTemplate();        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        ShortenRequest request = new ShortenRequest();        request.setUrl(url);        HttpEntity<ShortenRequest> entity = new HttpEntity<>(request, headers);        ResponseEntity<ShortenResponse> response = restTemplate.postForEntity(                "http://localhost:8080/shorten", entity, ShortenResponse.class);        return response.getBody().getShortUrl();    }}
```
### Matrix Diagonal Sum (задача из Leetcode).

Дана квадратная матрица. Найти сумму элементов на ее диагонали.

Пример:

```
Input:
matrix = 
[[1,2,3],
[4,5,6],
[7,8,9]]

Output: 15
```

```
Input:
matrix = 
[[1,1,1,1],
[1,1,1,1],
[1,1,1,1],
[1,1,1,1]]
Output: 4
```

Решение на Java:

```
public int diagonalSum(int[][] matrix) {    int sum = 0;    int n = matrix.length;    for (int i = 0; i < n; i++) {        sum += matrix[i][i]; // добавляем элементы главной диагонали        sum += matrix[i][n - i - 1]; // добавляем элементы побочной диагонали    }    if (n % 2 == 1) { // если размерность матрицы нечетная, вычитаем серединный элемент один раз, чтобы избежать двойного подсчета        sum -= matrix[n / 2][n / 2];    }    return sum;}
```

В данном решении мы проходимся по каждому элементу главной диагонали и побочной диагонали, добавляя значения в переменную sum. Затем, если размерность матрицы нечетная, мы вычитаем центральный элемент один раз, чтобы избежать двойного подсчета. В конце метод возвращает сумму элементов на диагоналях.

Это решение имеет временную сложность O(n), где n - размерность матрицы, и пространственную сложность O(1), так как мы не создаем дополнительных массивов или структур данных.
### Move Zeroes (задача из Leetcode).

Дан целочисленный массив nums. Необходимо переместить все нулевые элементы в конец массива, сохраняя относительный порядок элементов, не являющихся нулем. Решение должно производиться на месте, без использования дополнительного массива, а также должно иметь минимальную сложность по времени и пространству.

Пример:

```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```

```
public void moveZeroes(int[] nums) {    int index = 0;    for (int i = 0; i < nums.length; i++) {        if (nums[i] != 0) {            nums[index++] = nums[i];        }    }    while (index < nums.length) {        nums[index++] = 0;    }}
```

Описание алгоритма:  
Мы будем использовать два указателя: i и index. Сначала мы будем проходить по массиву nums с помощью указателя i и каждый раз, когда мы найдем ненулевой элемент, мы будем переносить его на место индекса index и увеличивать значение index. Затем мы заполняем оставшиеся позиции нулями. В результате все нули будут перемещены в конец массива, а все ненулевые элементы будут находиться в начале массива в том же порядке, что и в исходном массиве.

Данный алгоритм работает за линейное время O(n), где n - это длина массива nums.
### Given List names . Удалите первую букву из каждого имени и поверните отсортированный список.

Для решения этой задачи можно использовать методы Stream API, которые предоставляет Java.

Вот решение:

```
List<String> names = Arrays.asList("John", "Mary", "Peter", "Alice");List<String> modifiedNames = names.stream()        .map(name -> name.substring(1)) // удаление первой буквы из каждого имени        .sorted() // сортировка списка        .collect(Collectors.toList());System.out.println(modifiedNames); // [Alice, ohn, ary, eter]
```

Здесь мы создаем поток из списка имен, применяем к каждому элементу операцию map, которая удаляет первую букву из имени. Затем мы сортируем список и собираем его обратно в список с помощью операции collect.
### Перевернуть массив.

Для переворачивания массива в Java можно использовать цикл for, меняя местами элементы массива.

Вот пример кода, который переворачивает массив типа int:

```
int[] arr = {1, 2, 3, 4, 5};for (int i = 0; i < arr.length / 2; i++) {    int temp = arr[i];    arr[i] = arr[arr.length - 1 - i];    arr[arr.length - 1 - i] = temp;}System.out.println(Arrays.toString(arr)); // [5, 4, 3, 2, 1]
```

Здесь мы проходим половину массива с помощью цикла for. На каждой итерации мы меняем местами элементы, находящиеся на противоположных концах массива, используя переменную temp для временного хранения значения. После выполнения цикла массив будет перевернут, и мы можем вывести его на экран с помощью метода Arrays.toString().
### Проверить, является ли строка палиндромом.

Для проверки, является ли строка палиндромом в Java, можно сравнить каждый символ строки с его зеркальным отражением.

Вот пример кода для проверки, является ли строка палиндромом:

```
public static boolean isPalindrome(String str) {    int length = str.length();    for (int i = 0; i < length / 2; i++) {        if (str.charAt(i) != str.charAt(length - 1 - i)) {            return false;        }    }    return true;}
```

Здесь мы создаем метод isPalindrome, который принимает на вход строку str. В цикле for мы сравниваем символы строки str с их зеркальными отражениями. Если символы не совпадают, то строка не является палиндромом, и мы возвращаем значение false. Если же все символы совпадают, то строка является палиндромом, и мы возвращаем значение true.

Пример использования метода:

```
String str = "level";boolean isPalindrome = isPalindrome(str);System.out.println(isPalindrome); // true
```

Здесь мы создаем строку str со значением "level", вызываем метод isPalindrome, передавая ему эту строку в качестве аргумента, и выводим результат на экран.
### Написать простой алгоритм сортировки (Bubble, Selection или Shuttle). Как его можно улучшить?

- Пример `алгоритма сортировки пузырьком (Bubble sort)` :
    

```
public static void bubbleSort(int[] arr) {    int n = arr.length;    for (int i = 0; i < n - 1; i++) {        for (int j = 0; j < n - i - 1; j++) {            if (arr[j] > arr[j + 1]) {                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }}
```

Здесь мы используем два вложенных цикла for, чтобы перебрать все элементы массива и сравнить их между собой. Если элементы стоят в неправильном порядке, то мы меняем их местами с помощью временной переменной temp.

Данный алгоритм можно улучшить следующими способами:

- Добавить проверку, отсортирован ли уже массив. Если на какой-то итерации не происходит обмена, значит массив уже отсортирован, и можно завершить сортировку.
    
- Вместо двойного цикла использовать один цикл и флаг, который будет указывать, были ли за последний проход обмены. Если обменов не было, то сортировка завершена. Пример улучшенного алгоритма сортировки пузырьком:
    

```
public static void improvedBubbleSort(int[] arr) {    int n = arr.length;    boolean swapped = true;    for (int i = 0; i < n - 1 && swapped; i++) {        swapped = false;        for (int j = 0; j < n - i - 1; j++) {            if (arr[j] > arr[j + 1]) {                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;                swapped = true;            }        }    }}
```

Здесь мы добавили переменную swapped, которая указывает, были ли за последний проход обмены. Если обменов не было, то переменная swapped остается равной false, цикл завершается, и сортировка заканчивается. Также мы упростили внешний цикл и избавились от проверки уже отсортированных элементов при помощи формулы n - i - 1.

- `Алгоритм сортировки выбором (Selection sort)` работает следующим образом:
    
- Находим минимальный элемент в массиве.
    
- Меняем его местами с первым элементом.
    
- Повторяем шаги 1 и 2 для оставшейся части массива, начиная со второго элемента и до конца.  
    Вот пример реализации этого алгоритма на Java:
    

```
public static void selectionSort(int[] arr) {    int n = arr.length;    for (int i = 0; i < n - 1; i++) {        int minIdx = i;        for (int j = i + 1; j < n; j++) {            if (arr[j] < arr[minIdx]) {                minIdx = j;            }        }        int temp = arr[i];        arr[i] = arr[minIdx];        arr[minIdx] = temp;    }}
```

Для улучшения этого алгоритма можно использовать следующие оптимизации:

Добавить проверку, нужно ли менять элементы местами. Если элементы уже стоят в правильном порядке, то нет нужды менять их местами.  
Оптимизировать поиск минимального элемента. Вместо того, чтобы каждый раз проходить по всему неотсортированному массиву, можно сохранить индекс минимального элемента на предыдущих шагах сортировки и начинать следующий поиск от следующего элемента.  
Пример улучшенной реализации сортировки выбором:

```
public static void improvedSelectionSort(int[] arr) {    int n = arr.length;    for (int i = 0; i < n - 1; i++) {        int minIdx = i;        for (int j = i + 1; j < n; j++) {            if (arr[j] < arr[minIdx]) {                minIdx = j;            }        }        if (i != minIdx) {            int temp = arr[i];            arr[i] = arr[minIdx];            arr[minIdx] = temp;        }    }}
```

Здесь мы добавили проверку на равенство i и minIdx, чтобы не менять элементы местами, если они уже стоят в правильном порядке. Мы также сохраняем индекс минимального элемента на предыдущих шагах сортировки, чтобы начинать следующий поиск минимального элемента от следующего элемента.

- `Aлгоритм сортировки шаттле (shuttle sort)` работает следующим образом:
    

Проходим по массиву с начала до конца, и при нахождении элемента, который меньше предыдущего элемента, меняем их местами.  
Затем проходим от конца массива к началу и при нахождении элемента, который больше предыдущего элемента, меняем их местами.  
Это повторяется до тех пор, пока массив не будет полностью отсортирован.

Пример кода на Java:

```
public static void shuttleSort(int[] arr) {    boolean swapped = true;    int start = 0;    int end = arr.length - 1;    while (swapped) {        swapped = false;        // Первый проход по массиву        for (int i = start; i < end; i++) {            if (arr[i] > arr[i + 1]) {                int temp = arr[i];                arr[i] = arr[i + 1];                arr[i + 1] = temp;                swapped = true;            }        }        // Если ничего не поменялось, то выходим из цикла        if (!swapped) {            break;        }        swapped = false;        // Второй проход по массиву        for (int i = end - 1; i >= start; i--) {            if (arr[i] > arr[i + 1]) {                int temp = arr[i];                arr[i] = arr[i + 1];                arr[i + 1] = temp;                swapped = true;            }        }        // Смещаем границы массива        start++;        end--;    }}
```

Одним из способов улучшения алгоритма является оптимизация его производительности. Например, можно использовать более эффективный алгоритм сортировки, такой как быстрая сортировка (quicksort) или сортировка слиянием (merge sort).

Также можно оптимизировать алгоритм путем добавления дополнительных проверок на каждой итерации, чтобы избежать лишних перестановок, если массив уже отсортирован.

Использование параллельного программирования может ускорить работу алгоритма на многопроцессорных системах.
