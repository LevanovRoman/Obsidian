### Что такое и для чего нужен Spring core? Раскройте понятия Inversion of Control и Dependency Injection.

`Spring Core` - это базовый модуль Spring Framework, который предоставляет функциональность Inversion of Control (IoC) и Dependency Injection (DI).

`Inversion of Control (IoC)` - это принцип проектирования программного обеспечения, при котором контроль за созданием и жизненным циклом объектов переходит от приложения к контейнеру. Это означает, что вместо того, чтобы явно создавать объекты в коде, мы определяем конфигурацию объектов в контейнере IoC, который затем создает и управляет этими объектами.

`Dependency Injection (DI)` - это конкретный механизм реализации принципа IoC в Spring Framework. Он позволяет внедрять зависимости объектов в другие объекты, не создавая их явно в коде. В Spring DI, зависимости определяются в конфигурационных файлах, а Spring контейнер автоматически внедряет эти зависимости в нужные объекты.

Spring Core предоставляет много возможностей для работы с IoC и DI. С помощью Spring Core вы можете создавать и управлять объектами приложения, внедрять зависимости, решать проблему с избыточной сложности кода, связанной с созданием и настройкой объектов.

Пример конфигурации Spring DI с использованием XML файла:

```
<bean id="customerService" class="com.example.CustomerServiceImpl">
	<property name="customerDao" ref="customerDao"/>
</bean>

<bean id="customerDao" class="com.example.CustomerDaoImpl"/>
```

Здесь мы создаем два объекта - customerService и customerDao. Объект customerService зависит от объекта customerDao, который внедряется в customerService через метод setCustomerDao(). Мы определяем объекты и их зависимости в конфигурационном XML файле, а Spring Контейнер автоматически создает и управляет этими объектами.

Таким образом, Spring Core предоставляет мощную функциональность для работы с IoC и DI, что позволяет улучшать качество и упрощать процесс разработки программного обеспечения.
### Как "под капотом" работает Spring?

`Spring Framework` - это мощный и гибкий фреймворк для разработки приложений на Java, который предоставляет ряд функциональных возможностей, таких как управление транзакциями, управление жизненным циклом объектов, внедрение зависимостей и т.д.

Вот краткий обзор того, как "под капотом" работает Spring Framework:

- `Контейнер`: Основой Spring Framework является контейнер IoC (Inversion of Control), который управляет созданием, настройкой и жизненным циклом объектов приложения. В контейнере IoC объекты создаются и настраиваются на основе конфигурационных данных, которые могут быть определены с помощью XML, Java-аннотаций или Java-кода.
    
- `Внедрение зависимостей`: Spring Framework предоставляет механизм DI (Dependency Injection), который позволяет внедрять зависимости объектов в другие объекты без явного создания их экземпляров в коде. В Spring DI, зависимости определяются в конфигурационных файлах, а Spring контейнер автоматически внедряет эти зависимости в нужные объекты.
    
- `АОП`: Spring Framework также поддерживает АОП (Aspect Oriented Programming), который позволяет выносить общую функциональность, такую как логирование или аудит, в отдельные объекты-аспекты. Аспекты определяются с помощью конфигурационных файлов и могут применяться к коду приложения.
    
- `ORM`: Spring Framework предоставляет поддержку работы с ORM (Object-Relational Mapping) фреймворками, такими как Hibernate или JPA. Spring упрощает настройку и использование ORM, включая работу с транзакциями и управление сессиями.
    
- `Web-приложения`: Spring Framework предоставляет поддержку разработки веб-приложений, включая интеграцию со сторонними фреймворками, такими как Struts и JSF. Spring также предоставляет свой собственный MVC (Model-View-Controller) фреймворк - Spring MVC, который является гибким и расширяемым решением для создания веб-приложений.
    
- `Тестирование`: Spring Framework облегчает написание и запуск Unit Tests для приложений, включая поддержку интеграционного тестирования с базой данных и другими внешними системами.
    

В целом, Spring Framework представляет собой комплексное решение для создания приложений на Java, которое позволяет упростить и ускорить процесс разработки. Он предоставляет широкие возможности для работы с технологиями, включая базы данных, ORM, веб-серверы, а также инструментарий для тестирования и отладки приложений.
### Каков жизненный цикл объектов, создаваемых Spring?

Spring Framework управляет жизненным циклом объектов в приложении, создавая и уничтожая их. Жизненный цикл объектов в Spring зависит от того, как они создаются и интегрируются в контейнер приложения.

Объекты, созданные в Spring, могут иметь следующие состояния:

- `Configuration` - это состояние, когда объект еще не создан, но его конфигурация была определена в файле XML или аннотациях.
    
- `Instantiation` - это состояние, когда объект был создан с помощью вызова конструктора.
    
- `Initialization` - это состояние, когда объект проходит инициализацию после создания. В этой фазе выполняются все настройкии инъекции зависимостей.
    
- `Use` - это состояние, когда объект используется в приложении. В этой фазе объект выполняет свою работу.
    
- `Destruction` - это состояние, когда объект удаляется из памяти. В этой фазе выполняются все действия по освобождению ресурсов, которые были выделены объекту.
    

В Spring Framework есть два типа контейнеров, которые управляют жизненным циклом объектов: BeanFactory и ApplicationContext. BeanFactory является основным интерфейсом для управления объектами, а ApplicationContext предоставляет дополнительные функции, такие как поддержка межпоточной безопасности и событий приложения.

Spring создает объекты в контейнере и управляет их жизненным циклом. Когда контейнер запускается, он определяет все объекты, которые должны быть созданы и настроены. Затем контейнер создает эти объекты, выполняет все необходимые настройки и инъекции зависимостей. Когда объект больше не нужен, контейнер удаляет его из памяти.

Жизненный цикл объектов Spring может быть дополнительно управляемым с помощью различных методов, таких как аннотация `@PostConstruct` и интерфейсы InitializingBean и DisposableBean.
### Какие виды контекстов?

`Контексты Spring` - это объекты, которые хранят информацию о конфигурации и состоянии всех бинов (объектов), созданных в приложении. Spring поддерживает три вида контекстов:

- `ApplicationContext` - это основной контекст Spring, который предоставляет полный набор функций для управления бинами, таких как поддержка аспектно-ориентированного программирования, межпоточной безопасности и событий приложения.
    
- `WebApplicationContext` - это контекст, специализированный для обработки запросов веб-приложений. Он расширяет функциональность ApplicationContext, добавляя возможность использования BeanPostProcessors, связанных с Servlet API.
    
- `TestContext` - это контекст, который предоставляет инфраструктуру для тестирования Spring-приложений. Он позволяет создавать тесты, которые загружают конфигурацию Spring и проверяют работу бинов в изолированном окружении.
    

Контексты Spring позволяют управлять жизненным циклом объектов, создаваемых в приложении, и предоставляют дополнительную функциональность, такую как поддержка транзакций, кэширование данных и работа с базами данных.
### Чем полезны инструменты Maven, Ant, Gradle?

`Maven, Ant и Gradle` - это инструменты для автоматизации сборки и управления проектами на Java. Они предоставляют множество функций, которые помогают упростить и ускорить процесс разработки программного обеспечения.

Вот несколько преимуществ, которые предоставляют эти инструменты:

Автоматическая сборка и зависимости: Maven, Ant и Gradle могут автоматически собирать и компилировать исходный код, а также управлять зависимостями проекта. Это значительно упрощает процесс разработки и позволяет сосредоточиться на написании кода, а не на управлении проектом.

- `Управление конфигурацией`: Эти инструменты также позволяют управлять конфигурацией проекта, включая настройки сборки, запуск тестов, управление версиями и т.д. Это дает возможность легко изменять и переносить проекты между различными средами.
    
- `Поддержка CI/CD`: Maven, Ant и Gradle часто используются вместе с системами непрерывной интеграции (CI) и непрерывной доставки (CD) для автоматизации процессов разработки и упрощения процесса развертывания приложений.
    
- `Независимость от IDE`: Использование этих инструментов позволяет разрабатывать программное обеспечение без зависимости от конкретной среды разработки (IDE), что дает возможность использовать любую среду разработки на ваш выбор.
    
- `Эффективная работа в команде`: Maven, Ant и Gradle помогают управлять большими проектами и работать в команде более эффективно, так как они облегчают управление кодом и упрощают процесс сборки и зависимостей.
    
- `Поддержка множества языков программирования`: Некоторые из этих инструментов поддерживают не только Java, но и другие языки программирования, такие как C++, Python, Ruby и т.д.
    

Таким образом, инструменты Maven, Ant и Gradle предоставляют множество преимуществ для управления проектами на Java и используются в большинстве проектов на Java.
### Что такое и зачем нужен Hibernate? Раскройте понятие ORM.

`Hibernate` - это фреймворк для работы с базами данных, который обеспечивает прозрачный доступ к данным и упрощает работу с базами данных. Hibernate предоставляет инструменты для работы с СУБД на более высоком уровне абстракции, что позволяет разработчикам избежать написания сложного SQL-кода и сосредоточиться на разработке приложения.

Одной из ключевых функций Hibernate является ORM (Object-Relational Mapping), которая позволяет связывать объекты в Java со структурами данных в реляционных базах данных. ORM позволяет работать с данными на уровне объектов, обеспечивая более простой и наглядный код, а также возможность управления транзакциями и кэширования.

ORM работает следующим образом:

- `Определение модели данных`: Сначала необходимо определить модель данных, которую хранит приложение. Эта модель может быть описана с помощью классов Java, которые могут содержать поля, методы и другие характеристики.
    
- `Маппинг объектов на таблицы БД`: Затем, необходимо связать эти классы с таблицами в базе данных. Это делается с помощью механизма маппинга, который описывает отображение между классами Java и таблицами БД.
    
- `Создание запросов`: После того, как модель данных определена и объекты связаны с таблицами, можно выполнять запросы к базе данных при помощи стандартных операций CRUD (Create, Read, Update, Delete).
    

Hibernate предоставляет API для выполнения запросов к базе данных, а также инструменты для управления транзакциями и кэширования данных. Он позволяет разработчикам упростить работу с базой данных и сократить время на разработку приложения.

Таким образом, Hibernate - это мощный фреймворк для работы с базами данных, который позволяет использовать ORM для более простой и наглядной работы с данными в Java-приложениях. Он предоставляет широкие возможности для работы с базами данных, включая управление транзакциями и кэшированием, что делает его одним из самых популярных фреймворков для работы с базами данных в экосистеме Java.
###  Что такое Hibernate? В чем разница между JPA и Hibernate?

`Hibernate` - это фреймворк для работы с реляционными базами данных в Java. Он предоставляет объектно-ориентированный подход к работе с базами данных, что позволяет разработчикам избежать написания большого количества SQL-запросов и упрощает взаимодействие между приложениями и базой данных.

`JPA (Java Persistence API)` - это стандарт для работы с объектно-реляционным отображением (ORM) в Java. Он определяет API для работы с базами данных через ORM. JPA не является конкретной реализацией ORM, а скорее стандартизирует работу с ним.

Hibernate - одна из самых популярных реализаций JPA. Hibernate реализует спецификацию JPA и добавляет дополнительные функциональные возможности и расширения. В частности, Hibernate имеет свой язык запросов HQL (Hibernate Query Language), который позволяет разработчикам писать запросы на высоком уровне абстракции, а также его собственный кэш второго уровня, который улучшает производительность приложения.

Разница между JPA и Hibernate заключается в том, что JPA является стандартом, который имеет несколько реализаций, включая Hibernate, EclipseLink и OpenJPA. Hibernate - одна из самых популярных реализаций JPA и предоставляет наиболее широкий набор функциональных возможностей и расширений. Однако, использование JPA позволяет создавать более переносимый код между различными ORM-фреймворками, а также повышает уровень абстракции взаимодействия с базой данных
### Что такое каскадность? Как она используется в Hibernate?

`Каскадность (Cascade)` - это механизм в Hibernate, позволяющий автоматически распространять операции сохранения, обновления или удаления сущности на связанные с ней объекты.

Каскадность используется в Hibernate для управления связями между сущностями и уменьшения количества кода, необходимого для выполнения операций CRUD (Create, Read, Update, Delete) с базой данных. Без каскадности при изменении состояния одной сущности, например ее удалении, разработчику пришлось бы явно удалять все связанные сущности вручную.

Hibernate поддерживает несколько типов каскадности:

- `CascadeType.ALL` - операция каскадного удаления, сохранения и обновления применяется ко всем связанным сущностям.
    
- `CascadeType.PERSIST` - каскадное сохранение применяется ко всем связанным сущностям.
    
- `CascadeType.MERGE` - каскадное обновление применяется ко всем связанным сущностям.
    
- `CascadeType.REMOVE` - каскадное удаление применяется ко всем связанным сущностям.
    
- `CascadeType.DETACH` - каскадное отсоединение применяется ко всем связанным сущностям.
    
- `CascadeType.REFRESH` - каскадное обновление применяется ко всем связанным сущностям.
    
- `CascadeType.NONE` - каскадность не применяется ни к одной связанной сущности.
    

Каскадность позволяет управлять изменениями в базе данных через ORM, а также уменьшает количество кода, необходимого для выполнения операций CRUD. Однако следует использовать ее осторожно, чтобы избежать нежелательных побочных эффектов и неожиданных изменений в базе данных.
### Что такое и когда возникает LazyLoadingException?

`LazyLoadingException` - это исключение, которое возникает в Hibernate при попытке доступа к свойству или коллекции объекта, которая не была инициализирована из базы данных.

В Hibernate существует два режима загрузки объектов: lazy loading (ленивая загрузка) и eager loading (жадная загрузка). Ленивая загрузка означает, что свойства объекта или элементы коллекции будут загружаться только по мере непосредственного доступа к ним. Жадная загрузка, напротив, означает, что все свойства объекта или коллекции будут загружены одновременно с основным объектом.

Когда происходит ленивая загрузка, свойства объекта или элементы коллекции не загружаются до тех пор, пока к ним явно не обратятся. Если попытаться получить доступ к свойству или коллекции до её инициализации, то возникнет исключение LazyInitializationException.

Пример кода, который может вызвать LazyInitializationException:

```
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// Загружаем объект из базы
User user = (User) session.load(User.class, 1L);

tx.commit();
session.close();

// Попытка получить доступ к коллекции до её инициализации
System.out.println(user.getOrders().size()); // вызовет LazyInitializationException
```

В данном примере мы получаем объект User из базы данных в режиме ленивой загрузки. Затем, мы закрываем сессию Hibernate и пытаемся получить доступ к коллекции заказов пользователя до её инициализации. Это вызовет исключение LazyInitializationException.

Чтобы избежать этой ошибки, необходимо либо использовать жадный режим загрузки, либо явно инициализировать свойства объекта или элементы коллекции до того, как к ним обратятся.
### Может ли entity-класс быть абстрактным классом?

Да, entity-класс может быть абстрактным классом в Hibernate.

Абстрактный класс является классом, у которого не реализованы некоторые методы и который не может быть инстанцирован напрямую. Вместо этого он может быть использован только как базовый класс для других классов, которые должны реализовать его абстрактные методы.

В Hibernate entity-класс представляет отображение таблицы из базы данных на Java-объект. Абстрактный класс может определять общие поля и методы для сущностей, которые наследуют его, что может быть полезным в случае, когда несколько сущностей имеют общие свойства.

Таким образом, entity-класс может быть абстрактным классом, если это имеет смысл для конкретной модели данных и будет соответствовать логике приложения.
### Что такое entity manager? За что отвечает?

`Entity Manager` - это интерфейс в JPA, который предоставляет API для управления жизненным циклом сущностей. Entity Manager отвечает за управление связью между объектами Java и базой данных, что позволяет разработчикам использовать объектно-ориентированный подход при работе с базой данных.

Основные задачи Entity Manager включают:

- Создание, удаление и обновление сущностей в базе данных.
    
- Поиск и выборка сущностей из базы данных.
    
- Контроль жизненного цикла сущностей, таких как управление их состоянием (managed, detached, transient).
    
- Кэширование и оптимизация запросов к базе данных.
    
- Управление транзакциями.
    
- Работа с ленивой загрузкой (lazy loading) и Eager-загрузкой (Eager loading).
    

Entity Manager может быть получен через EntityManagerFactory, который создает и конфигурирует соединение с базой данных. Объект EntityManager привязывается к определенной транзакции и управляет делегированием инструкций SQL в базу данных. Также он используется для работы с контекстом персистентности сущностей, что позволяет сохранять изменения объектов Java в базу данных и извлекать данные из нее.

В целом, Entity Manager является важным компонентом JPA, который отвечает за управление связью между объектами Java и базой данных, что делает работу с базой данных более простой и гибкой.

### Как «под капотом» работает @Transactional?

Аннотация `@Transactional` в Spring Framework предоставляет абстракцию управления транзакциями базы данных. Она позволяет гарантировать целостность данных при выполнении операций в базе данных и обеспечивает откат изменений в случае возникновения ошибок.

Когда метод помечен аннотацией `@Transactional`, Spring создает прокси-объект для этого метода, который обеспечивает управление транзакцией. При вызове метода, Spring начинает новую транзакцию в базе данных и выполняет код метода в рамках этой транзакции.

Если метод успешно выполняется, Spring закрывает транзакцию и сохраняет изменения в базе данных. Если же возникает ошибка, Spring откатывает транзакцию и отменяет все изменения в базе данных.

В рамках одной транзакции могут выполняться несколько методов с аннотацией [@Transactional](https://habr.com/users/Transactional). В этом случае, все эти методы будут выполняться в контексте одной транзакции. Если один из методов завершается неудачно, то все изменения в базе данных, выполненные в рамках этой транзакции, будут отменены.

Для работы с транзакциями Spring использует объект PlatformTransactionManager, который предоставляет унифицированный интерфейс для управления транзакциями баз данных, таких как JDBC, Hibernate, JPA и другие.

Таким образом, аннотация `@Transactional` в Spring Framework является мощным инструментом для управления транзакциями баз данных. Она позволяет гарантировать целостность данных при выполнении операций в базе данных и обеспечивает удобный и безопасный способ работы с транзакциями.

### Какие возможности Spring предоставляет для коммуникации с базой данных?

Spring Framework предоставляет несколько способов взаимодействия с базами данных, в том числе:

- `JDBC (Java Database Connectivity)` - это стандартный инструмент для взаимодействия с базами данных в языке Java. Spring предоставляет удобные абстракции над JDBC, такие как JdbcTemplate, NamedParameterJdbcTemplate и SimpleJdbcInsert, которые значительно упрощают работу с базами данных.
    
- `ORM (Object-Relational Mapping)` - это подход к взаимодействию с базами данных, при котором объекты Java могут быть преобразованы в строки таблицы базы данных и наоборот. Spring поддерживает несколько ORM-фреймворков, таких как Hibernate, JPA и MyBatis.
    
- `NoSQL` - это тип баз данных, который не использует SQL для запросов и хранения данных. Spring поддерживает несколько NoSQL-баз данных, таких как MongoDB, Couchbase и Redis.
    

В Spring Framework есть набор модулей, которые обеспечивают интеграцию с различными базами данных. Например, модуль Spring Data предоставляет абстракции над различными базами данных, что позволяет уменьшить количество кода, необходимого для работы с каждой базой данных. Также Spring предоставляет поддержку транзакций, кэширования данных и возможности для работы с базами данных в многопоточной среде.
###  Каковы признаки того, что класс Java Bean? Чем POJO отличается от Java Bean?

`Java Bean` - это класс, который соответствует определенным стандартам, которые позволяют использовать его в различных библиотеках и фреймворках Java. Класс Java Bean имеет следующие признаки:

- Имеет конструктор без аргументов.
    
- Имеет доступные для чтения и записи свойства (поля) с помощью геттеров и сеттеров.
    
- Реализует интерфейс Serializable, чтобы объекты этого класса можно было сериализовать.
    
- Может поддерживать события, т.е. иметь методы-обработчики, вызываемые при возникновении определенных событий. POJO (Plain Old Java Object) - это обычный Java-класс, который не зависит от каких-либо фреймворков или библиотек. Он не обязан следовать каким-либо стандартам, но может содержать любое количество свойств, методов и конструкторов. POJO может использоваться в качестве простого контейнера данных или служить элементом сложной бизнес-логики.
    

Основное отличие между Java Bean и POJO заключается в том, что Java Bean является специальным типом POJO, который соответствует определенным стандартам. Java Bean обычно используется в качестве компонента, который можно переиспользовать в разных частях приложения. POJO же может иметь любую структуру и использоваться для решения специфических задач.

Пример Java Bean:

```
public class User implements Serializable {
	private String name;    
	private int age;        
	
	public User() {}
	        
	public String getName() { return name; }    
	public void setName(String name) { this.name = name; } 
	
	public int getAge() { return age; }    
	public void setAge(int age) { this.age = age; }
}
```

В этом примере класс User соответствует стандартам Java Bean: у него есть конструктор без аргументов, доступные для чтения и записи свойства (name и age), реализован интерфейс Serializable.

Пример POJO:

```
public class Calculator { 
	public int add(int a, int b) { return a + b; }    
	public int subtract(int a, int b) { return a - b; }}
```

В этом примере класс Calculator не соответствует стандартам Java Bean (нет геттеров/сеттеров и конструктора без аргументов), но все еще может использоваться для выполнения конкретного задания - математических операций.
### Опишите механизм инъекции зависимости в Spring.

Механизм инъекции зависимости (Dependency Injection - DI) в Spring Framework предназначен для управления зависимостями между компонентами приложения. С помощью DI можно создавать слабые связи между классами и конфигурировать их поведение без изменения кода.

DI в Spring работает следующим образом:

- `Создание бинов` - Spring создает объекты, называемые бинами, которые будут использоваться в приложении. Бины создаются на основе конфигурации, которая может быть представлена в виде XML-файла, аннотаций или кода на Java.
    
- `Инъекция зависимостей` - после создания бинов, Spring ищет зависимости каждого бина и пытается найти другие бины, которые могли бы удовлетворить эти зависимости. Если необходимые зависимости найдены, то они внедряются в данный бин.
    
- `Жизненный цикл бинов` - Spring управляет жизненным циклом бинов, что позволяет выполнять дополнительные действия до и после создания бина, например, проводить валидацию данных или установку значений по умолчанию.
    
- `Обработка событий` - Spring поддерживает обработку событий, которые могут возникать при создании или уничтожении бинов. Например, можно определить методы-обработчики для событий инициализации или уничтожения объектов.
    

Существуют различные способы осуществления инъекции зависимостей в Spring Framework:

- `Конструктор` - используется для передачи зависимостей через параметры конструктора.
    
- `Сеттер` - используется для передачи зависимостей через вызовы соответствующих сеттеров.
    
- `Аннотации` - используются для указания Spring, какие поля или методы должны быть внедрены.
    
- `Интерфейсы` - используются для реализации интерфейсов, например, JDBC Template или JPA EntityManager.
    

С помощью DI в Spring Framework можно легко управлять зависимостями между компонентами приложения и делать код более гибким и модульным.
### Чем Spring singleton отличается от prototype?

В Spring Framework есть два основных типа области видимости бинов - singleton и prototype.

`Singleton` - это область видимости, при которой Spring создает единственный экземпляр бина для всего приложения. Это означает, что при каждом запросе на получение бина будет возвращаться один и тот же объект. Singleton является областью видимости по умолчанию в Spring.

Основное отличие между singleton и prototype заключается в том, что singleton создает только один экземпляр бина для всего приложения, в то время как prototype создает новый экземпляр при каждом запросе.

Выбор между singleton и prototype зависит от конкретных требований приложения. Если бин должен быть общедоступным и использоваться в разных частях приложения, то лучше использовать singleton. Если же бин используется только в определенной части приложения и не должен быть общедоступным, то лучше использовать prototype, чтобы избежать накопления ресурсов.

Некоторые другие типы области видимости, которые поддерживаются Spring Framework, - request, session и global session. Они позволяют ограничить область видимости бина до определенного HTTP-запроса или сессии.
