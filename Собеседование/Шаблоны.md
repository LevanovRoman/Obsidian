### Какие есть шаблоны проектирования ?

Шаблоны проектирования — это проверенные решения типовых проблем, возникающих при проектировании ПО. Они помогают сделать систему более гибкой, модульной и поддерживаемой. В зависимости от их предназначения, шаблоны проектирования делятся на три основные категории:

``Порождающие шаблоны (Creational Patterns)``

Эти шаблоны связаны с процессом создания объектов, делая систему независимой от способа их создания, композиции и представления.

- `Одиночка (Singleton)`: Обеспечивает создание только одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру.
- `Абстрактная фабрика (Abstract Factory)`: Позволяет создавать семейства связанных объектов без указания их конкретных классов.
- `Фабричный метод (Factory Method)`: Определяет интерфейс для создания объекта, но оставляет выбор класса объекта подклассам.
- `Строитель (Builder)`: Позволяет создавать сложные объекты пошагово.
- `Прототип (Prototype)`: Позволяет копировать существующие объекты без создания зависимости от их классов.

``Структурные шаблоны (Structural Patterns)``

Описывают способы построения объектов и классов в более крупные структуры, при этом сохраняя гибкость и эффективность структур.

- `Адаптер (Adapter)`: Позволяет объектам с несовместимыми интерфейсами работать вместе.
- `Мост (Bridge)`: Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.
- `Компоновщик (Composite)`: Позволяет группировать объекты в древовидные структуры для представления иерархий часть-целое.
- `Декоратор (Decorator)`: Динамически добавляет новые обязанности объектам.
- `Фасад (Facade)`: Предоставляет упрощённый интерфейс к сложной системе классов, библиотеке или фреймворку.
- `Прокси (Proxy)`: Предоставляет заместителя или плейсхолдер для другого объекта для контроля доступа к нему.

``Поведенческие шаблоны (Behavioral Patterns)``

Рассматривают эффективное взаимодействие и распределение обязанностей между объектами.

- `Наблюдатель (Observer)`: Позволяет объектам получать уведомления об изменениях состояния других объектов.
- `Стратегия (Strategy)`: Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
- `Команда (Command)`: Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов.
- `Состояние (State)`: Позволяет объекту изменять своё поведение при изменении его внутреннего состояния.
- `Цепочка обязанностей (Chain of Responsibility)`: Позволяет передавать запросы вдоль цепочки обработчиков. При этом каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепочке.
- `Посредник (Mediator)`: Уменьшает связанность множества классов, вынося взаимодействие между объектами в один класс-посредник.
- `Итератор (Iterator)`: Предоставляет способ последовательного доступа к элементам объекта-агрегата без раскрытия его внутреннего представления.

Эти шаблоны не являются жёсткими правилами, а скорее рекомендациями и лучшими практиками, которые можно адаптировать под конкретные задачи и условия проекта.