### Что такое Stream в Java?

`Stream (поток)` в Java - это объект, который представляет собой последовательность элементов данных и позволяет выполнять операции над этими элементами. Потоки предоставляют декларативный способ обработки данных без использования циклов.

Stream API добавлено в Java 8 и предоставляет множество операций для работы с потоками данных. Операции можно разделить на промежуточные и терминальные.

`Промежуточные операции` выполняются над элементами данных и возвращают новый поток. Примеры таких операций: filter(), map(), distinct(), sorted().

`Терминальные операции` завершают обработку потока данных и возвращают результат. Примеры таких операций: forEach(), toArray(), reduce(), collect().

Вместе с лямбда-выражениями Stream API позволяет работать с коллекциями и другими структурами данных более удобным и выразительным способом.

### Какие методы в интерфейсе Stream?

Интерфейс Stream в Java предоставляет ряд методов, которые позволяют выполнять операции над элементами потока данных. Некоторые из этих методов:

- `filter(Predicate<T> predicate)`: фильтрует элементы потока на основе заданного условия, передаваемого в качестве аргумента в виде объекта типа Predicate.
    
- `map(Function<T, R> mapper)`: преобразует каждый элемент потока с помощью функции, передаваемой в качестве аргумента в виде объекта типа Function<T, R>.
    
- `flatMap(Function<T, Stream<R>> mapper)`: принимает функцию, которая преобразует каждый элемент потока в другой поток, и возвращает объединенный поток из всех полученных потоков.
    
- `distinct()`: удаляет повторяющиеся элементы из потока.
    
- `sorted()`: сортирует элементы потока по умолчанию в естественном порядке или с помощью компаратора.
    
- `limit(long maxSize)`: ограничивает количество элементов в потоке до указанного числа.
    
- `skip(long n)`: пропускает n элементов в потоке.
    
- `forEach(Consumer<T> action)`: выполняет действие для каждого элемента потока.
    
- `toArray()`: возвращает массив, содержащий элементы потока.
    
- `reduce(BinaryOperator<T> accumulator)`: сворачивает элементы потока в один объект с помощью заданной функции, передаваемой в качестве аргумента в виде объекта типа BinaryOperator.
    
- `collect(Collector<T, A, R> collector)`: выполняет сбор элементов потока с помощью заданного коллектора, передаваемого в качестве аргумента в виде объекта типа Collector<T, A, R>.
    

Кроме этих методов, интерфейс Stream также содержит ряд дополнительных методов для работы с числами, строками, датами и временем, а также для преобразования данных в параллельный поток или обратно.
### Чем отличается метод map от flatMap?

Метод map и метод flatMap являются функциями высшего порядка в языке программирования, которые используются для манипулирования коллекциями данных.

`Метод map` принимает функцию, которая преобразует каждый элемент коллекции, возвращает новую коллекцию с тем же числом элементов. Например:

```
val numbers = listOf(1, 2, 3)
val squaredNumbers = numbers.map { it * it }
// squaredNumbers == [1, 4, 9]
```

`Метод flatMap`, с другой стороны, принимает функцию, которая возвращает коллекцию для каждого элемента входной коллекции, а затем объединяет эти коллекции в одну выходную коллекцию. Например:

```
val words = listOf("hello", "world")
val letters = words.flatMap { it.toList() }
// letters == ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
```


Таким образом, основное отличие между map и flatMap заключается в том, что map преобразует каждый элемент входной коллекции в единственный элемент выходной коллекции, тогда как flatMap может генерировать любое количество элементов выходной коллекции для каждого элемента входной коллекции.
### Какой функциональный интерфейс употребляет способ filter?

Метод filter является функцией высшего порядка в языке программирования, который используется для фильтрации элементов коллекции на основе заданного условия. Он принимает предикатную функцию - функцию, которая принимает элемент и возвращает булево значение, указывающее, должен ли элемент быть включен в выходную коллекцию.

Таким образом, для метода filter используется функциональный интерфейс Predicate, определенный в пакете java.util.function. Этот интерфейс имеет один метод test, который принимает объект типа T и возвращает булево значение.

Пример использования метода filter с функциональным интерфейсом Predicate:

```
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = numbers.filter { it % 2 == 0 }
// evenNumbers == [2, 4]
```

Здесь переданный лямбда-выражение { it % 2 == 0 } является предикатной функцией, которая проверяет, является ли число четным или нет.

### Каковы основные принципы Stream API?

Stream API - это новый функциональный интерфейс Java 8, который позволяет работать с коллекциями объектов в более функциональном стиле.

Основные принципы Stream API:

- `Ленивость`: операции над потоком не выполняются немедленно, а откладываются до конечной операции.
    
- `Поток данных`: поток представляет последовательность элементов и может поступать из коллекций, массивов, файлов и других источников.
    
- `Функциональность`: операции над потоком реализуют функциональный подход программирования и могут быть скомбинированы для создания цепочек операций.
    
- `Распараллеливание`: Stream API позволяет эффективно распараллеливать операции над потоком данных, что позволяет ускорить обработку больших объемов данных.
    
- `Неизменяемость`: Stream API не изменяет исходную коллекцию при выполнении операций над потоком, а возвращает новый поток или определенное значение.
    
- `Операции трансформации`: Stream API содержит много операций трансформации, таких как фильтрация, отображение, сортировка, слияние, разбиение и др., которые позволяют легко и эффективно обрабатывать поток данных.
    
- `Операции редукции`: Stream API также содержит операции редукции, такие как суммирование, нахождение минимального и максимального значения, свертка и др., которые позволяют получить единственное значение из потока данных.

