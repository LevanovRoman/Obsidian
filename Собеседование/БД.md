###  В чем разница между реляционными и нереляционными базами данных?

Реляционные и нереляционные базы данных (NoSQL) - это два основных типа баз данных, используемых в разработке программного обеспечения. Основные отличия между ними заключаются в способе организации и хранения данных.

`Реляционные базы данных (RDBMS) являются структурированными базами данных, которые хранят данные в таблицах с предопределенными полями, каждое поле имеет определенный тип данных`. Каждая строка таблицы представляет отдельную запись, а столбцы таблицы представляют собой атрибуты записи. Реляционные базы данных используют язык SQL (Structured Query Language) для работы с данными. Они обладают строгой схемой данных, что означает, что они требуют заранее определенной структуры таблиц и соответствующих связей между ними.

`Нереляционные базы данных (NoSQL) - это базы данных, которые не используют табличную структуру для хранения данных, а вместо этого используют другие форматы хранения, такие как документы, графы или ключ-значение`. Нереляционные базы данных могут хранить и обрабатывать большие объемы неструктурированных данных, таких как данные социальных сетей, системы рекомендаций и IoT (интернет вещей). Они обладают гибкой схемой данных, что означает, что они не требуют заранее определенной структуры таблиц и связей между ними. Вместо этого данные хранятся в документах или других форматах без установленной структуры.

Таким образом, основное отличие между реляционными и нереляционными базами данных заключается в способе организации данных - реляционные базы данных используют табличную структуру с заранее определенными полями, а нереляционные базы данных хранят данные в других форматах без установленной структуры.
### Назовите главные характеристики транзакций. Каковы уровни изоляции транзакций?

`Транзакция (transaction)` - это последовательность операций, которые выполняются как единое целое и либо успешно завершаются, либо откатываются к начальному состоянию в случае возникновения ошибки.

Главные характеристики транзакций:

ACID-свойства - транзакции должны быть атомарными, согласованными, изолированными и долговечными.

- `Атомарность (Atomicity)` - все операции транзакции должны быть выполнены или не выполнены вообще.
    
- `Согласованность (Consistency)` - транзакция должна приводить базу данных в согласованное состояние.
    
- `Изолированность (Isolation)` - каждая транзакция должна работать в изолированном режиме, т.е. изменения, внесенные одной транзакцией, не должны видны другим транзакциям до тех пор, пока первая транзакция не будет завершена.
    
- `Долговечность (Durability)` - после успешного завершения транзакции изменения должны сохраняться в базе данных.
    

Уровень изоляции (isolation level) - определяет, насколько транзакции должны быть изолированы друг от друга. В Java есть четыре уровня изоляции:

- `READ UNCOMMITTED (чтение незафиксированных данных)`
    
- `READ COMMITTED (чтение зафиксированных данных)`
    
- `REPEATABLE READ (повторяемое чтение)`
    
- `SERIALIZABLE (сериализуемость)`
    

Уровень изоляции READ UNCOMMITTED позволяет одной транзакции видеть изменения, которые еще не были зафиксированы другой транзакцией. Уровень изоляции SERIALIZABLE обеспечивает полную изоляцию транзакций, при которой они ведут себя как будто выполняются последовательно, хотя фактически могут выполняться параллельно.

### Какая разница между Statement и PreparedStatement?

`Statement и PreparedStatement` - это два класса, которые используются для выполнения запросов к базе данных в Java. Основная разница между ними заключается в том, как они обрабатывают параметры запроса.

`Statement` используется для создания статического SQL-запроса без параметров. Такой запрос выполняется каждый раз при вызове метода execute() объекта Statement. Например:

```
Statement stmt = connection.createStatement();
String sql = "SELECT * FROM users WHERE name = 'John'";
ResultSet rs = stmt.executeQuery(sql);
```

PreparedStatement же позволяет создавать динамический SQL-запрос с параметрами. Этот запрос компилируется только один раз, а затем может быть многократно выполнен с разными значениями параметров. Параметры указываются в виде плейсхолдеров "?" в SQL-запросе. Например:

```
PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM users WHERE name = ?");
pstmt.setString(1, "John");
ResultSet rs = pstmt.executeQuery();
```

При использовании PreparedStatement значительно повышается производительность запросов, особенно если нужно выполнить множество запросов с одним и тем же шаблоном, но с разными значениями параметров. Кроме того, PreparedStatement защищает от SQL-инъекций, так как параметры автоматически экранируются при выполнении запроса.

### Как сохраняются соотношения one-to-one, one-to-many и many-to-many в виде таблиц?

Соотношения между таблицами в реляционных базах данных могут быть выражены как one-to-one (один-к-одному), one-to-many (один-ко-многим) или many-to-many (многие-ко-многим).

Для хранения соотношения один-к-одному между двумя сущностями можно использовать одну из двух стратегий:

- В первой стратегии каждая таблица содержит ссылку на другую таблицу по первичному ключу. Таким образом, каждая строка в одной таблице имеет только одну связанную строку в другой таблице.
    
- Во второй стратегии одна из таблиц содержит первичный ключ, который также является внешним ключом для связанной таблицы. Таким образом, каждая строка в одной таблице связана с одной строкой в другой таблице, а каждая строка во второй таблице может быть связана с несколькими строками в первой таблице.
    

Для хранения соотношения один-ко-многим между двумя сущностями используется вторая стратегия, упомянутая выше.

Для хранения соотношения многие-ко-многим между двумя сущностями требуется создание дополнительной таблицы-связки, которая содержит первичные ключи обеих таблиц. Таким образом, каждая строка в таблице-связке связывает одну строку из первой таблицы с одной строкой из второй таблицы, а каждая из этих таблиц может быть связана с несколькими строками в другой таблице.

Например, предположим, что есть две таблицы - "Пользователи" и "Заказы". Каждый пользователь может иметь несколько заказов, а каждый заказ может быть связан только с одним пользователем. В этом случае мы можем использовать вторую стратегию для хранения соотношения один-ко-многим между таблицами "Пользователи" и "Заказы". Для хранения соотношения многие-ко-многим, нам необходимо создать дополнительную таблицу-связку "ПользователиЗаказы", которая будет содержать первичные ключи обеих таблиц.
### Что такое нормализация базы данных? Приведите примеры реального проекта.

Нормализация базы данных - это процесс проектирования базы данных с целью устранения избыточных, повторяющихся или несогласованных данных. Цель нормализации базы данных состоит в том, чтобы минимизировать размер базы данных и обеспечить целостность данных, предотвращая дублирование информации.

Существует несколько стадий нормализации, которые описывают отношение между таблицами и атрибутами, и каждый уровень нормализации имеет свои правила, которые определяют, какие типы данных должны быть вынесены в отдельные таблицы и как они должны быть связаны друг с другом.

Примеры реального проекта включают в себя любую базу данных, используемую в приложениях, таких как системы управления контентом (CMS), системы управления заказами (OMS), системы управления кастомер-реляшенз (CRM), системы управления отношениями с поставщиками (SRM) и другие подобные системы.

Например, пусть есть база данных для онлайн-магазина, которая включает в себя таблицы "Клиенты", "Заказы", "Товары" и "Отзывы". В этом случае мы можем применить следующие принципы нормализации:

- `Первый уровень нормализации`: каждая таблица должна иметь уникальный идентификатор, то есть первичный ключ. В таблице "Клиенты", например, первичным ключом может быть ID клиента, а в таблице "Заказы" - номер заказа.
    
- `Второй уровень нормализации`: выделение зависимых данных в отдельную таблицу. Например, для таблицы "Заказы" мы можем выделить отдельную таблицу "Детали заказов", которая будет содержать информацию о количестве и цене каждого заказанного товара.
    
- `Третий уровень нормализации`: выделение повторяющихся данных в отдельную таблицу. Например, если у нас есть несколько клиентов с одним и тем же адресом доставки, мы можем выделить отдельную таблицу "Адреса доставки", которая будет содержать информацию об адресах доставки и связываться с таблицей "Клиенты".
    

Обычно в реальных проектах базы данных проходят несколько стадий нормализации, чтобы гарантировать эффективность, точность и безопасность хранения информации.
