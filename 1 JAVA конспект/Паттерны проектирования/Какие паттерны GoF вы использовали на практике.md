#### Какие паттерны GoF вы использовали на практике? Приведите примеры.

- `Паттерн "Фабричный метод" (Factory Method)` - использовался для создания объектов определенного типа, в зависимости от параметров. Например, если требуется создать экземпляр класса, который может иметь различные реализации, то фабричный метод обеспечивает гибкость и удобство при создании объектов.
    
- `Паттерн "Абстрактная фабрика" (Abstract Factory)` - использовался для создания семейств связанных объектов. Например, если требуется создать объекты, которые зависят друг от друга и должны быть созданы вместе, то абстрактная фабрика предоставляет механизм для этого.
    
- `Паттерн "Одиночка" (Singleton)` - использовался для создания объекта, который может быть создан только один раз. Например, если требуется создать объект, который используется множество раз в приложении, то с помощью паттерна Одиночка можно гарантировать, что он будет создан только один раз.
    
- `Паттерн "Стратегия" (Strategy)` - использовался для определения алгоритма, который может быть заменен на другой алгоритм без изменения интерфейса. Например, если требуется реализовать алгоритм сортировки, то можно использовать паттерн Стратегия для того, чтобы выбирать различные методы сортировки в зависимости от конкретных требований.
    
- `Паттерн "Наблюдатель" (Observer)` - использовался для создания механизма, который позволяет объектам-наблюдателям получать оповещения об изменении состояния других объектов. Например, если требуется создать систему, которая обрабатывает события, то паттерн Наблюдатель может быть использован для того, чтобы отправлять уведомления о событиях всем заинтересованным объектам.
    
- `Паттерн "Декоратор" (Decorator)` - использовался для динамического добавления функциональности к объекту без изменения его класса. Например, если требуется добавить дополнительное поведение к объекту, то можно использовать паттерн Декоратор, который позволяет обернуть объект в другой объект с дополнительным поведением.
    
- `Паттерн "Адаптер" (Adapter)` - использовался для преобразования интерфейса одного класса в интерфейс другого класса. Например, если имеется класс с неподходящим интерфейсом для использования в приложении, то можно создать адаптер, который преобразует интерфейс класса в нужный интерфейс.
    
- `Паттерн "Итератор" (Iterator)` - использовался для последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления. Например, если требуется перебрать элементы коллекции в порядке их добавления, то можно использовать паттерн Итератор, который предоставляет методы для доступа к элементам коллекции.
    
- `Паттерн "Шаблонный метод" (Template Method)` - использовался для определения основных шагов алгоритма, оставляя подклассам возможность переопределения некоторых шагов. Например, если требуется реализовать алгоритм, который имеет схожие шаги, но различную реализацию для каждого шага, то можно использовать паттерн Шаблонный метод, чтобы предоставить базовую реализацию алгоритма и дать возможность подклассам переопределять отдельные шаги.
    
- `Паттерн "Фасад" (Facade)` - использовался для предоставления упрощенного интерфейса для сложной системы. Например, если имеется сложная система, которая состоит из многих классов и компонентов, то можно создать фасад, который скрывает сложность системы и предоставляет простой интерфейс для взаимодействия с ней.
    
- `Паттерн "Компоновщик" (Composite)` - использовался для создания иерархических древовидных структур объектов, которые могут быть обработаны единообразно. Например, если требуется представить структуру файловой системы, то можно использовать паттерн Компоновщик для создания древовидной структуры, где папки и файлы являются узлами дерева.
    
- `Паттерн "Прототип" (Prototype)` - использовался для создания новых объектов путем клонирования существующих объектов. Например, если требуется создать множество объектов с одинаковыми свойствами, то можно использовать паттерн Прототип, чтобы создать первоначальный объект и затем клонировать его для создания остальных объектов.
    
- `Паттерн "Цепочка обязанностей" (Chain of Responsibility)` - использовался для построения цепочки объектов, которые могут обрабатывать запросы последовательно до тех пор, пока один из объектов не обработает запрос. Например, если имеется система обработки запросов и каждый запрос может быть обработан несколькими объектами, то можно использовать паттерн Цепочка обязанностей, чтобы создать цепочку объектов, которые будут обрабатывать запросы последовательно.
    
- `Паттерн "Состояние" (State)` - использовался для изменения поведения объекта в зависимости от его состояния. Например, если имеется объект, который может находиться в различных состояниях, то можно использовать паттерн Состояние, чтобы определить различное поведение объекта в зависимости от его текущего состояния.
    
- `Паттерн "Посетитель" (Visitor)` - использовался для добавления новых операций к классам, не изменяя их исходного кода. Например, если имеется множество классов и требуется добавить новую операцию, которая будет выполняться для каждого класса, то можно использовать паттерн Посетитель, чтобы добавить эту операцию без изменения исходного кода классов.
    
- `Паттерн "Мост" (Bridge)` - использовался для разделения абстракции и реализации, чтобы они могли изменяться независимо друг от друга. Например, если имеется класс, который представляет графический объект, то можно использовать паттерн Мост, чтобы разделить абстракцию графического объекта и его реализацию.
    
- `Паттерн "Легковес" (Flyweight)` - использовался для оптимизации работы с большим количеством мелких объектов, которые могут быть разделены на общие и уникальные части. Например, если требуется работать с большим количеством объектов, каждый из которых имеет много общих идентификаторов, то можно использовать паттерн Легковес, чтобы разделить общие и уникальные части объектов и оптимизировать использование памяти.
    
- `Паттерн "Прокси" (Proxy)` - использовался для создания объекта-заместителя, который может контролировать доступ к другому объекту. Например, если имеется объект, к которому нужно предоставить доступ только определенным пользователям, то можно использовать паттерн Прокси, который будет контролировать доступ к этому объекту.
    
- `Паттерн "Команда" (Command)` - использовался для инкапсуляции запроса в виде объекта, что позволяет отделить источник запроса от его исполнения. Например, если требуется реализовать систему, которая обрабатывает запросы, то можно использовать паттерн Команда, чтобы инкапсулировать запрос в виде объекта и передавать его на обработку.
    
- `Паттерн "Интерпретатор" (Interpreter)` - использовался для определения грамматики языка и создания интерпретатора для выполнения заданных операций. Например, если имеется язык, который нужно интерпретировать, то можно использовать паттерн Интерпретатор, который предоставляет механизм для описания грамматики языка и выполнения заданных операций.
    
- `Паттерн "Снимок" (Memento)` - использовался для сохранения состояния объекта и его восстановления в будущем. Например, если требуется сохранить состояние объекта перед выполнением каких-то действий, то можно использовать паттерн Снимок, чтобы сохранить его состояние и восстановить его в будущем.
    
- `Паттерн "Строитель" (Builder)` - использовался для создания сложных объектов путем последовательного добавления их компонентов. Например, если требуется создать объекты, которые имеют много параметров и зависят друг от друга, то можно использовать паттерн Строитель, который позволяет последовательно добавлять компоненты объекта.
    
- `Паттерн "Инкапсуляция состояния" (Encapsulated State)` - использовался для инкапсуляции изменений состояния объекта в соответствующие классы. Например, если требуется реализовать систему, которая обработает изменения состояний объектов, то можно использовать паттерн Инкапсуляция состояния, который позволяет инкапсулировать изменения состояния объекта в соответствующие классы.
    
- `Паттерн "Соблюдение интерфейса" (Interface Compliance)` - использовался для создания классов, которые соответствуют определенному интерфейсу. Например, если требуется реализовать систему, которая работает с объектами, то можно использовать паттерн Соблюдение интерфейса, который обеспечивает соответствие класса заданному интерфейсу.
    
- `Паттерн "Реестр" (Registry)` - использовался для хранения ссылок на объекты в централизованном месте. Например, если требуется иметь доступ к объектам из разных частей приложения, то можно использовать паттерн Реестр, который позволяет хранить ссылки на объекты в централизованном месте и давать доступ к ним из разных частей приложения.