### Промежуточные операции

Вот несколько примеров некоторых промежуточных операций, которые можно применять к Java Stream:

#### filter()

Этот метод используется для фильтрации элементов из потока, которые соответствуют определенному предикату в Java. Затем эти отфильтрованные элементы составляют новый поток. Давайте взглянем на пример, чтобы лучше понять лучше.

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); List<Integer> even = numStream.filter(n -> n % 2 == 0) .collect(Collectors.toList()); System.out.println(even);  `

Вывод:

[98]

Объяснение: В этом примере видно, что четные элементы (делящиеся на 2) фильтруются с помощью метода filter() и сохраняются в целочисленном списке numStream, содержимое которого печатается позже. Поскольку 98 — единственное четное целое число в потоке, оно печатается в выводе.

#### map()

Этот метод используется для создания нового потока путем выполнения сопоставленных функций над элементами исходного входного потока. Возможно, новый поток имеет другой тип данных. Пример выглядит следующим образом:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); List<Integer> d = numStream.map(n -> n*2) .collect(Collectors.toList()); System.out.println(d);  `

Вывод:

[86, 130, 2, 196, 126]

Объяснение: Здесь мы видим, что метод map() используется для простого удвоения каждого элемента потока numStream. Как видно из вывода, каждый из элементов в потоке успешно удвоен.

#### distinct()

Этот метод используется для извлечения только отдельных элементов в потоке путем фильтрации дубликатов. Пример того же выглядит следующим образом:

`Stream<Integer> numStream = Stream.of(43,65,1,98,63,63,1); List<Integer> numList = numStream.distinct() .collect(Collectors.toList()); System.out.println(numList);  `

Вывод:

[43, 65, 1, 98, 63]

Объяснение: В этом случае для numStream используется метод different(). Он извлекает все отдельные элементы в списке numList путем удаления дубликатов из потока. Как видно из выводных данных, дубликатов нет, в отличие от входного потока, который изначально имел два дубликата (63 и 1).

#### peek()

Этот метод используется для отслеживания промежуточных изменений перед выполнением терминальной операции. Это означает, что peek() можно использовать для выполнения операции над каждым элементом потока для создания потока, над которым могут выполняться дальнейшие промежуточные операции.

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); List<Integer> nList = numStream.map(n -> n*10) .peek(n->System.out.println("Mapped: "+ n)) .collect(Collectors.toList()); System.out.println(nList);  `

Вывод:

Mapped: 430 Mapped: 650 Mapped: 10 Mapped: 980 Mapped: 630 [430, 650, 10, 980, 630]

Объяснение: Здесь метод peek() используется для генерации промежуточных результатов, поскольку метод map() применяется к элементам потока. Здесь мы можем заметить, что даже до применения терминальной операции collect() для печати окончательного содержимого списка в операторе print результат для каждого сопоставления элемента потока печатается последовательно заранее.

#### sorted()

Метод sorted() используется для сортировки элементов потока. По умолчанию он сортирует элементы в порядке возрастания. Также можно указать конкретный порядок сортировки в качестве параметра. Пример реализации этого метода выглядит следующим образом:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); numStream.sorted().forEach(n -> System.out.println(n));  `

Вывод:

1 43 ​​63 65 98

Объяснение: Здесь метод sorted() используется для сортировки элементов потока в порядке возрастания по умолчанию (поскольку конкретный порядок не указан). Можно увидеть, что элементы, напечатанные в выводе, упорядочены в возрастающем порядке.

### Терминальные операции

Вот несколько примеров некоторых терминальных операций, которые можно применять к потокам Java:

#### forEach()

Метод forEach() используется для перебора всех элементов потока и выполнения функции для каждого элемента один за другим. Это действует как альтернатива операторам цикла, таким как for, while и другим. Пример:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); numStream.forEach(n -> System.out.println(n));  `

Вывод:

43 65 1 98 63

Объяснение: Здесь метод forEach() используется для печати каждого элемента потока один за другим.

#### count()

Метод count() используется для извлечения общего количества элементов, присутствующих в потоке. Он похож на метод size(), который часто используется для определения общего количества элементов в коллекции. Пример использования метода count() с Java Stream выглядит следующим образом:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); System.out.println(numStream.count());`

Вывод:

5

Объяснение: Поскольку поток numStream содержит 5 целочисленных элементов, то при использовании для него метода count() вывод будет 5.

#### collect()

Метод collect() используется для выполнения изменяемых сокращений элементов потока. Его можно использовать для удаления содержимого из потока после завершения обработки. Для проведения редукций он использует класс Collector.

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); List<Integer> odd = numStream.filter(n -> n % 2 == 1) .collect(Collectors.toList()); System.out.println(odd);  `

Вывод:

[43, 65, 1, 63]

Объяснение: В этом примере все нечетные элементы в потоке фильтруются и собираются/сокращаются в список с именем odd (нечетные). В конце печатается список нечетных.

#### min() и max()

Метод min(), как следует из названия, может использоваться в потоке для поиска в нем минимального элемента. Точно так же метод max() можно использовать для поиска максимального элемента в потоке. Давайте попробуем понять, как их можно использовать, на примере:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); int smallest = numStream.min((m, n) -> Integer.compare(m, n)).get(); System.out.println("Smallest element: " + smallest);  `

`numStream = Stream.of(43, 65, 1, 98, 63); int largest = numStream.max((m, n) -> Integer.compare(m, n)).get(); System.out.println("Largest element: " + largest);  `

Вывод:

Smallest element: 1 Largest element: 98

Объяснение: В этом примере мы напечатали наименьший элемент в потоке numStream с помощью метода min() и самый большой элемент с помощью метода max(). Обратите внимание, что здесь перед применением метода max() мы снова добавили элементы в поток numStream. Это связано с тем, что min() является терминальной операцией и уничтожает содержимое исходного потока, возвращая только окончательный результат (который в данном случае был целочисленным “smallest”).

#### findAny() и findFirst()

findAny() возвращает любой элемент потока как Optional. Если поток пуст (empty), он вернет также значение Optional, которое будет пустым. findFirst() возвращает первый элемент потока как Optional. Как и в случае с методом findAny(), метод findFirst() также возвращает пустой параметр Optional, если соответствующий поток пуст. Давайте взглянем на следующий пример, основанный на этих методах:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); Optional<Integer> opt = numStream.findFirst();System.out.println(opt); numStream = Stream.empty(); opt = numStream.findAny();System.out.println(opt);  `

Вывод:

Optional[43] Optional.empty

Объяснение: Здесь, в первом случае, метод findFirst() возвращает первый элемент потока как Optional. Затем, когда поток переназначается как пустой поток, метод findAny() возвращает пустой Optional.

#### allMatch(), anyMatch() и noneMatch()

Метод allMatch() используется для проверки того, соответствуют ли все элементы в потоке определенному предикату, и возвращает логическое значение _true_, если это так, в противном случае возвращается _false_. Если поток пуст, он возвращает _true_. Метод anyMatch() используется для проверки того, соответствует ли какой-либо из элементов в потоке определенному предикату. Он возвращает _true_, если это так, и _false_ в противном случае. Если поток пуст, он возвращает _false_. Метод noneMatch() возвращает _true_, если ни один элемент потока не соответствует предикату, и _false_ в противном случае. Пример, иллюстрирующий это, выглядит следующим образом:

`Stream<Integer> numStream = Stream.of(43, 65, 1, 98, 63); boolean flag = numStream.allMatch(n -> n1); System.out.println(flag); numStream = Stream.of(43, 65, 1, 98, 63); flag = numStream.anyMatch(n -> n1); System.out.println(flag); numStream = Stream.of(43, 65, 1, 98, 63); flag = numStream.noneMatch(n -> n==1);System.out.println(flag);  `

Вывод:

false true false

Объяснение: Для потока numStream, содержащего 1 в качестве элемента, метод allMatch() возвращает _false_, так как все элементы не равны 1, а только один из них. Метод anyMatch() возвращает _true_, поскольку хотя бы один из элементов равен 1. Метод noneMatch() возвращает _false_, поскольку 1 действительно существует как элемент в этом потоке.